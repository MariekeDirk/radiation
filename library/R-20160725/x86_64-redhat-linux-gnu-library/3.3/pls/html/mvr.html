<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Partial Least Squares and Principal Component Regression</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for mvr {pls}"><tr><td>mvr {pls}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Partial Least Squares and Principal Component Regression</h2>

<h3>Description</h3>

<p>Functions to perform partial least squares regression (PLSR),
canonical powered partial least squares (CPPLS) or
principal component regression (PCR), with a formula interface.
Cross-validation can be used.  Prediction, model extraction, plot,
print and summary methods exist.
</p>


<h3>Usage</h3>

<pre>
mvr(formula, ncomp, Y.add, data, subset, na.action,
    method = pls.options()$mvralg,
    scale = FALSE, validation = c("none", "CV", "LOO"),
    model = TRUE, x = FALSE, y = FALSE, ...)
plsr(..., method = pls.options()$plsralg)
cppls(..., Y.add, weights, method = pls.options()$cpplsalg)
pcr(..., method = pls.options()$pcralg)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>formula</code></td>
<td>
<p>a model formula.  Most of the <code>lm</code> formula
constructs are supported.  See below.</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>the number of components to include in the model (see below).</p>
</td></tr>
<tr valign="top"><td><code>Y.add</code></td>
<td>
<p>a vector or matrix of additional responses containing
relevant information about the observations.  Only used for <code>cppls</code>.</p>
</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>
<p>an optional data frame with the data to fit the model from.</p>
</td></tr>
<tr valign="top"><td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr valign="top"><td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain missing values.  The default is set by
the <code>na.action</code> setting of <code><a href="../../base/html/options.html">options</a></code>, and is
<code><a href="../../stats/html/na.fail.html">na.fail</a></code> if that is unset.  The &lsquo;factory-fresh&rsquo;
default is <code><a href="../../stats/html/na.fail.html">na.omit</a></code>.  Another possible value is
<code>NULL</code>, no action.  Value <code><a href="../../stats/html/na.fail.html">na.exclude</a></code> can be
useful.  See <code><a href="../../stats/html/na.fail.html">na.omit</a></code> for other alternatives.</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
<p>the multivariate regression method to be used.  If
<code>"model.frame"</code>, the model frame is returned.</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>numeric vector, or logical.  If numeric vector, <i>X</i>
is scaled by dividing each variable with the corresponding element
of <code>scale</code>.  If <code>scale</code> is <code>TRUE</code>, <i>X</i> is scaled
by dividing each variable by its sample standard deviation.  If
cross-validation is selected, scaling by the standard deviation is
done for every segment.</p>
</td></tr>
<tr valign="top"><td><code>validation</code></td>
<td>
<p>character.  What kind of (internal) validation to
use.  See below.</p>
</td></tr>
<tr valign="top"><td><code>model</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, the model matrix is returned.</p>
</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, the response is returned.</p>
</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>
<p>a vector of individual weights for the observations.
Only used for <code>cppls</code>.  (Optional)</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>additional arguments, passed to the underlying fit
functions, and <code>mvrCv</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions fit PLSR, CPPLS or PCR models with 1, <i>&hellip;</i>,
<code>ncomp</code> number of components.  Multi-response models are fully
supported.
</p>
<p>The type of model to fit is specified with the <code>method</code>
argument. Four PLSR algorithms are available: the kernel algorithm
(<code>"kernelpls"</code>), the wide kernel algorithm (<code>"widekernelpls"</code>),
SIMPLS (<code>"simpls"</code>) and the classical orthogonal scores algorithm
(<code>"oscorespls"</code>). One CPPLS algorithm is available (<code>"cppls"</code>)
providing several extensions to PLS. One PCR algorithm
is available: using the singular value decomposition (<code>"svdpc"</code>).
If <code>method</code> is <code>"model.frame"</code>, the model frame is returned.
The functions <code>pcr</code>, <code>plsr</code> and <code>cppls</code>
are wrappers for <code>mvr</code>, with different values for <code>method</code>.
</p>
<p>The <code>formula</code> argument should be a symbolic formula of the form
<code>response ~ terms</code>, where <code>response</code> is the name of the
response vector or matrix (for multi-response models) and <code>terms</code>
is the name of one or more predictor matrices, usually separated by
<code>+</code>, e.g., <code>water ~ FTIR</code> or <code>y ~ X + Z</code>.  See
<code><a href="../../stats/html/lm.html">lm</a></code> for a detailed description.  The named
variables should exist in the supplied <code>data</code> data frame or in
the global environment.  Note: Do not use <code>mvr(mydata$y ~
    mydata$X, ...)</code>, instead use <code>mvr(y ~ X, data = mydata,
    ...)</code>.  Otherwise, <code><a href="predict.mvr.html">predict.mvr</a></code> will not work properly.
The chapter <span class="samp">Statistical models in R</span> of the manual <span class="samp">An
    Introduction to R</span> distributed with <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> is a good reference on
formulas in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>.
</p>
<p>The number of components to fit is specified with the argument
<code>ncomp</code>.  It this is not supplied, the maximal number of
components is used (taking account of any cross-validation).
</p>
<p>If <code>validation = "CV"</code>, cross-validation is performed.  The number and
type of cross-validation segments are specified with the arguments
<code>segments</code> and <code>segment.type</code>.  See <code><a href="mvrCv.html">mvrCv</a></code> for
details.  If <code>validation = "LOO"</code>, leave-one-out cross-validation
is performed.  It is an error to specify the segments when
<code>validation = "LOO"</code> is specified.
</p>
<p>By default, the cross-validation will be performed serially.  However,
it can be done in parallel using functionality in the
<code><a href="../../lattice/html/splom.html">parallel</a></code> package by setting the option <code>parallel</code> in
<code><a href="pls.options.html">pls.options</a></code>.  See <code><a href="pls.options.html">pls.options</a></code> for the
differnt ways to specify the parallelism.  See also Examples below.
</p>
<p>Note that the cross-validation is optimised for speed, and some
generality has been sacrificed.  Especially, the model matrix is
calculated only once for the complete cross-validation, so models like
<code>y ~ msc(X)</code> will not be properly cross-validated.  However,
scaling requested by <code>scale = TRUE</code> is properly cross-validated.
For proper cross-validation of models where the model matrix must be
updated/regenerated for each segment, use the separate function
<code><a href="crossval.html">crossval</a></code>.
</p>


<h3>Value</h3>

<p>If <code>method = "model.frame"</code>, the model frame is returned.
Otherwise, an object of class <code>mvr</code> is returned.
The object contains all components returned by the underlying fit
function.  In addition, it contains the following components:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>validation</code></td>
<td>
<p>if validation was requested, the results of the
cross-validation.  See <code><a href="mvrCv.html">mvrCv</a></code> for details.</p>
</td></tr>
<tr valign="top"><td><code>fit.time</code></td>
<td>
<p>the elapsed time for the fit.  This is used by
<code><a href="crossval.html">crossval</a></code> to decide whether to turn on tracing.</p>
</td></tr>
<tr valign="top"><td><code>na.action</code></td>
<td>
<p>if observations with missing values were removed,
<code>na.action</code> contains a vector with their indices.  The
class of this vector is used by functions like <code>fitted</code> to
decide how to treat the observations.</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>the number of components of the model.</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
<p>the method used to fit the model.  See the argument
<code>method</code> for possible values.</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>if scaling was requested (with <code>scale</code>), the
scaling used.</p>
</td></tr>
<tr valign="top"><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
<tr valign="top"><td><code>terms</code></td>
<td>
<p>the model terms.</p>
</td></tr>
<tr valign="top"><td><code>model</code></td>
<td>
<p>if <code>model = TRUE</code>, the model frame.</p>
</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
<p>if <code>x = TRUE</code>, the model matrix.</p>
</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
<p>if <code>y = TRUE</code>, the model response.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ron Wehrens and Bjørn-Helge Mevik</p>


<h3>References</h3>

<p>Martens, H., Næs, T. (1989) <em>Multivariate calibration.</em>
Chichester: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="kernelpls.fit.html">kernelpls.fit</a></code>,
<code><a href="widekernelpls.fit.html">widekernelpls.fit</a></code>,
<code><a href="simpls.fit.html">simpls.fit</a></code>,
<code><a href="oscorespls.fit.html">oscorespls.fit</a></code>,
<code><a href="cppls.fit.html">cppls.fit</a></code>,
<code><a href="svdpc.fit.html">svdpc.fit</a></code>,
<code><a href="mvrCv.html">mvrCv</a></code>,
<code><a href="crossval.html">crossval</a></code>,
<code><a href="../../stats/html/loadings.html">loadings</a></code>,
<code><a href="scores.html">scores</a></code>,
<code><a href="scores.html">loading.weights</a></code>,
<code><a href="coef.mvr.html">coef.mvr</a></code>,
<code><a href="predict.mvr.html">predict.mvr</a></code>,
<code><a href="mvrVal.html">R2</a></code>,
<code><a href="mvrVal.html">MSEP</a></code>,
<code><a href="mvrVal.html">RMSEP</a></code>,
<code><a href="plot.mvr.html">plot.mvr</a></code></p>


<h3>Examples</h3>

<pre>
data(yarn)
## Default methods:
yarn.pcr &lt;- pcr(density ~ NIR, 6, data = yarn, validation = "CV")
yarn.pls &lt;- plsr(density ~ NIR, 6, data = yarn, validation = "CV")
yarn.cppls &lt;- cppls(density ~ NIR, 6, data = yarn, validation = "CV")

## Alternative methods:
yarn.oscorespls &lt;- mvr(density ~ NIR, 6, data = yarn, validation = "CV",
                      method = "oscorespls")
yarn.simpls &lt;- mvr(density ~ NIR, 6, data = yarn, validation = "CV",
                  method = "simpls")

## Not run: 
## Parallelised cross-validation, using transient cluster:
pls.options(parallel = 4) # use mclapply
pls.options(parallel = quote(makeCluster(4, type = "PSOCK"))) # use parLapply
## A new cluster is created and stopped for each cross-validation:
yarn.pls &lt;- plsr(density ~ NIR, 6, data = yarn, validation = "CV")
yarn.pcr &lt;- pcr(density ~ NIR, 6, data = yarn, validation = "CV")

## Parallelised cross-validation, using persistent cluster:
library(parallel)
## This creates the cluster:
pls.options(parallel = makeCluster(4, type = "PSOCK"))
## The cluster can be used several times:
yarn.pls &lt;- plsr(density ~ NIR, 6, data = yarn, validation = "CV")
yarn.pcr &lt;- pcr(density ~ NIR, 6, data = yarn, validation = "CV")
## The cluster should be stopped manually afterwards:
stopCluster(pls.options()$parallel)

## Parallelised cross-validation, using persistent MPI cluster:
## This requires the packages snow and Rmpi to be installed
library(parallel)
## This creates the cluster:
pls.options(parallel = makeCluster(4, type = "MPI"))
## The cluster can be used several times:
yarn.pls &lt;- plsr(density ~ NIR, 6, data = yarn, validation = "CV")
yarn.pcr &lt;- pcr(density ~ NIR, 6, data = yarn, validation = "CV")
## The cluster should be stopped manually afterwards:
stopCluster(pls.options()$parallel)
## It is good practice to call mpi.exit() or mpi.quit() afterwards:
mpi.exit()

## End(Not run)

## Multi-response models:
data(oliveoil)
sens.pcr &lt;- pcr(sensory ~ chemical, ncomp = 4, scale = TRUE, data = oliveoil)
sens.pls &lt;- plsr(sensory ~ chemical, ncomp = 4, scale = TRUE, data = oliveoil)

## Classification
# A classification example utilizing additional response information
# (Y.add) is found in the cppls.fit manual ('See also' above).
</pre>

<hr /><div style="text-align: center;">[Package <em>pls</em> version 2.5-0 <a href="00Index.html">Index</a>]</div>
</body></html>
